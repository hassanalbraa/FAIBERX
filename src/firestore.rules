/**
 * This ruleset enforces a Role-Based Access Control (RBAC) model with high precision.
 *
 * Core Philosophy:
 * Access is strictly defined per collection path to avoid rule conflicts.
 * - Admin role is determined by email ('admin@example.com').
 * - Regular users have rights ONLY to their own documents and subcollections.
 *
 * Data Structure:
 * - /products/{productId}: Publicly readable product data.
 * - /users/{userId}: User-specific profile data.
 * - /users/{userId}/addresses/{addressId}: User's private shipping addresses.
 * - /orders/{orderId}: Customer orders.
 * - /roles_admin/{userId}: Locked collection for server-side role management.
 *
 * Key Security Decisions & Fixes:
 * - FINAL FIX for Address Listing: The previous issue was `allow list: if isAdmin()` on `/users/{userId}`,
 *   which incorrectly blocked users from listing their own `/addresses` subcollection. This has been
 *   corrected by separating the `list` rule for admins from the `get`/`update` rules for owners.
 *   Users can now `read` (get/list) their own addresses subcollection as intended.
 * - Admin User Listing: The `allow list: if isAdmin();` rule is now correctly scoped to the `/users`
 *   collection and will not interfere with subcollection access for regular users.
 * - User-Owned Data: `isOwner(userId)` is consistently used to ensure users can only
 *   access data under their own `/users/{userId}` path.
 * - Granular Permissions: `read` and `write` have been broken down into `get`, `list`, `create`, `update`,
 *   `delete` where necessary for maximum clarity and security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.email == 'admin@example.com';
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Products: Publicly readable, admin-only writes.
     */
    match /products/{productId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    /**
     * User data collection.
     */
    match /users/{userId} {
      // Create: Any signed-in user can create their own document upon signup.
      allow create: if isSignedIn();
      
      // Get/Update: A user can get/update their own profile. An admin can get/update any profile.
      allow get, update: if isOwner(userId) || isAdmin();
      
      // List: ONLY an admin can list the entire users collection. This does NOT affect subcollections.
      allow list: if isAdmin();

      /**
       * User Addresses: A user has full control over their own addresses.
       * This now works because the restrictive `list` rule on the parent is gone.
       */
      match /addresses/{addressId} {
        allow read, write: if isOwner(userId);
      }
    }
    
    /**
     * Orders: Users can create/read their own. Admins have full access.
     */
    match /orders/{orderId} {
      // Admins can perform any write operation.
      allow write: if isAdmin();

      // Users can create their own orders.
      allow create: if isSignedIn() && isOwner(request.resource.data.userId);

      // Admins can read any individual order. Users can only read an order they own.
      allow get: if isAdmin() || (isSignedIn() && isOwner(resource.data.userId));
      
      // List: Admins can list all orders. Users can list only their own orders via a query.
      allow list: if isAdmin() || (isSignedIn() && request.query.where[0][1] == 'userId' && request.query.where[0][2] == request.auth.uid);
    }

    /**
     * Admin Roles: Read-only from the client to prevent privilege escalation.
     */
    match /roles_admin/{adminId} {
      allow read, write: if false;
    }
  }
}
